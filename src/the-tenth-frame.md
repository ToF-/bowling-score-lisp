# The Tenth Frame
Once the tenth frame has been played, the only rolls that can be counted are the extra ones generated by a strike or a spare in the tenth frame. Thus, the score for 12 strike is exactly 300. 

```
(define-test after-tenth-frame-extra-rolls-count-only-as-bonus
    (assert-equal 300 (score (list 10 10 10 10 10 10 10 10 10 10 10 10))))
```
The test fails:
```
 | Failed Form: (SCORE (LIST 10 10 10 10 10 10 10 10 10 10 10 10))
 | Expected 300 but saw 330
 |
AFTER-TENTH-FRAME-EXTRA-ROLLS-COUNT-ONLY-AS-BONUS: 0 assertions passed, 1 failed.
```
Let's respond with a hard coded comparison for now.
```
(defun score (rolls)
  (cond ((null rolls) 0)
        ((equal (list 10 10 10 10 10 10 10 10 10 10 10 10) rolls) 300) 
        ((strike rolls) (+ (frame-plus-bonus rolls) (score (cdr rolls))))
        ((spare rolls) (+ (frame-plus-bonus rolls) (score (cddr rolls))))
        (t (+ (car rolls) (score (cdr rolls))))))
```
The tenth frame limit implies that we count frames as we are collecting points, and make the frame being equal to 10 a termination condition.
Let's start by adding a `frame` parameter to our function.
```
(defun score-at-frame (frame rolls)
  (cond ((null rolls) 0)
        ((equal (list 10 10 10 10 10 10 10 10 10 10 10 10) rolls) 300) 
        ((strike rolls) (+ (frame-plus-bonus rolls) (score-at-frame frame (cdr rolls))))
        ((spare rolls) (+ (frame-plus-bonus rolls) (score-at-frame frame (cddr rolls))))
        (t (+ (car rolls) (score-at-frame frame (cdr rolls))))))

(defun score (rolls)
  (score-at-frame 0 rolls))
```
Now we can add a clause to the `cond` and increase the `frame` argument at each recursive call.
```
(defun score-at-frame (frame rolls)
  (cond ((null rolls) 0)
        ((>= frame 10) 0)
        ((strike rolls) (+ (frame-plus-bonus rolls) (score-at-frame (1+ frame) (cdr rolls))))
        ((spare rolls) (+ (frame-plus-bonus rolls) (score-at-frame (1+ frame) (cddr rolls))))
        (t (+ (car rolls) (score-at-frame (1+ frame) (cdr rolls))))))
```
The last clause is wrong of coure, since we increase the frame number while advancing only for one roll in the list.
And one of the tests is telling us that:
```
 | Failed Form: (SCORE (LIST 5 5 4 0 8 1 10 0 10 10 10 10 4 6 0 0))
 | Expected 151 but saw 141
 |
AFTER-SOME-STRIKES-AND-SPARES-BONUS-ROLLS-ARE-ADDED: 2 assertions passed, 1 failed.
```
The frame counting is incorrect here:
```
frame: 0 1 2 3 4 5 6  7 8  9  10 
rolls: 5 5 4 0 8 1 10 0 10 10 10 10 4 6 0 0
```
Let's fix the frame increase on the last clause:
```
(defun score-at-frame (frame rolls)
  (cond ((null rolls) 0)
        ((>= frame 10) 0)
        ((strike rolls) (+ (frame-plus-bonus rolls) (score-at-frame (1+ frame) (cdr rolls))))
        ((spare rolls) (+ (frame-plus-bonus rolls) (score-at-frame (1+ frame) (cddr rolls))))
        (t (+ (car rolls) (any (cadr rolls))  (score-at-frame (1+ frame) (cddr rolls))))))
```
There are 3 possibilities on this last clause:
- `rolls` contains only 1 roll (and it's not a 10) : then `(any (cadr rolls))` is 0 and `NIL` is passed to the next recursive call
- `rolls` contains 2 rolls (ant it's not a spare) : then the 2 rolls are added and `rolls` and `NIL` is passed to the next recursive call
- `rolls` contains more than 2 rolls (and we don't have a spare): then we add these rolls and continue with the correct frame number

Let's add some assertions to increase our confidence in that reasoning:
```
(define-test after-tenth-frame-extra-rolls-count-only-as-bonus
    (assert-equal 300 (score (list 10 10 10 10 10 10 10 10 10 10 10 10)))
    (assert-equal 266 (score (list 10 10 10 10 10 10 10 10 10 4 6 2)))
    (assert-equal 262 (score (list 10 10 10 10 10 10 10 10 10 4 5)))
    (assert-equal 264 (score (list 10 10 10 10 10 10 10 10 10 4 6 0))))
```
They all pass.
