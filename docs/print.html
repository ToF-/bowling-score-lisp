<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Bowling Score in Lisp</title>
        <meta name="robots" content="noindex" />


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body>
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var html = document.querySelector('html');
            var sidebar = null;
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="a-lisp-environment.html"><strong aria-hidden="true">1.</strong> A Lisp Environment</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="requirements.html"><strong aria-hidden="true">1.1.</strong> Requirements</a></li><li class="chapter-item expanded "><a href="sbcl.html"><strong aria-hidden="true">1.2.</strong> SBCL</a></li><li class="chapter-item expanded "><a href="writing-tests.html"><strong aria-hidden="true">1.3.</strong> Writing Tests</a></li><li class="chapter-item expanded "><a href="automating-tasks.html"><strong aria-hidden="true">1.4.</strong> Automating tasks</a></li></ol></li><li class="chapter-item expanded "><a href="the-bowling-score-kata.html"><strong aria-hidden="true">2.</strong> The Bowling Score Kata</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="simple-games.html"><strong aria-hidden="true">2.1.</strong> Simple Games</a></li><li class="chapter-item expanded "><a href="strikes-and-spares.html"><strong aria-hidden="true">2.2.</strong> Strikes & Spares</a></li><li class="chapter-item expanded "><a href="the-tenth-frame.html"><strong aria-hidden="true">2.3.</strong> The Tenth Frame</a></li></ol></li><li class="chapter-item expanded "><a href="the-score-program.html"><strong aria-hidden="true">3.</strong> The Score Program</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="input-and-output.html"><strong aria-hidden="true">3.1.</strong> Input & Output</a></li><li class="chapter-item expanded "><a href="processing-games.html"><strong aria-hidden="true">3.2.</strong> Processing Games</a></li><li class="chapter-item expanded "><a href="final-assembly.html"><strong aria-hidden="true">3.3.</strong> Final Assembly</a></li></ol></li><li class="chapter-item expanded "><a href="source-code.html"><strong aria-hidden="true">4.</strong> Source Code</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Bowling Score in Lisp</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="a-lisp-environment"><a class="header" href="#a-lisp-environment">A Lisp Environment</a></h1>
<p>Welcome to the Lisp Bowling Score Kata! </p>
<p>In this little book, we learn how to code in Common Lisp applying Test Driven Development. </p>
<p>We will be using the <a href="https://www/sbcl/org/">Steel Bank Common Lisp</a> with as few external libraries as possible.</p>
<p>The Bowling Score Kata exercise is about writing a program that can compute scores at the Ten-Pin Bowling, given lists of rolls points made by players.
We start with setting up the simplest environment that will allow us to code this kata in Common Lisp.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="requirements"><a class="header" href="#requirements">Requirements</a></h1>
<h2 id="the-game-of-ten-pins-bowling"><a class="header" href="#the-game-of-ten-pins-bowling">The Game of Ten-Pins Bowling</a></h2>
<p>Here's a reminder of the rules of bowling (<a href="https://bowlingforbeginners.com/bowling-rules/">source</a>):</p>
<ul>
<li>The ultimate goal is to knock down all ten pins on your first turn.</li>
<li>During each frame, each player gets two attempts to knock down all ten pins.</li>
<li>Turns are called “frames,” and each player plays ten frames in a game.</li>
<li>Knocking down all the pins on your first throw is called a strike.</li>
<li>If you miss at least one pin on the first throw and then knock down any remaining pins on your second throw, it’s called a spare.</li>
<li>If a player bowls a strike in the tenth frame, they get two more throws within that frame. If they get a spare in the final frame, the player gets to throw one more ball.</li>
<li>Open frames are simply frames that left at least one pin standing.</li>
<li>Scoring is based on the number of pins knocked down. Except, when you get a spare, you get 10 plus the number of pins you knock down during your next throw. If you get a strike, you get 10 plus the number of pins you knock down with your next two throws.</li>
</ul>
<p>Here's an example of score (<a href="https://en.wikipedia.org/wiki/Ten-pin_bowling">source</a>):</p>
<p align="center"> <img src="./images/scoring-example.jpg" width="75%" /> </p>
<h2 id="the-program"><a class="header" href="#the-program">The Program</a></h2>
<p>Our task will be to write a program which, given a series of rolls delivered by Ten Pin Bowling players, computes the scores of these players. The roll values will be consistent with the game rules: no illegal values (such as -1, 11 or values totaling more than 10 in a frame). In test cases where not all rolls have been played, the resulting value should be the score obtained as if all the subsequent future rolls would be zero.</p>
<p>Our program's task will consist in reading the standard input stream, parsing the given numbers, computing and printing the scores. </p>
<h3 id="input-specification"><a class="header" href="#input-specification">Input specification</a></h3>
<ul>
<li><em>T</em> : the number of test cases, then <em>T</em> test cases follows.</li>
<li>each test case consists in 2 lines:
<ul>
<li><em>N</em> : the number of rolls delivered, ( 0 &lt; N ≤ 21 )</li>
<li><em>R1,..Rn</em> - the rolls delivered ( 0 ≤ R ≤ 10 )</li>
</ul>
</li>
</ul>
<h3 id="output-specification"><a class="header" href="#output-specification">Output specification</a></h3>
<p>For each test case output one integer: the score made by the player after they played all the rolls in the test case.</p>
<h3 id="example"><a class="header" href="#example">Example</a></h3>
<p><strong>Input:</strong></p>
<pre><code>3
2
4 6
4
10 7 3 5
12
10 10 10 10 10 10 10 10 10 10 10 10
</code></pre>
<p><strong>Output:</strong></p>
<pre><code>10
40
300
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="sbcl"><a class="header" href="#sbcl">SBCL</a></h1>
<p><a href="https://www.sbcl.org/">SBCL</a> is the most popular implementation of common lisp, and it generates machine code that is fast (not that it matters much for our kata!).</p>
<p>To quote <a href="https://en.wikipedia.org/wiki/Steel_Bank_Common_Lisp">Wikipedia</a>:</p>
<blockquote>
<p>Steel Bank Common Lisp (SBCL) is a free Common Lisp implementation that features a high-performance native compiler, Unicode support and threading.</p>
<p>The name &quot;Steel Bank Common Lisp&quot; is a reference to Carnegie Mellon University Common Lisp from which SBCL forked: Andrew Carnegie made his fortune in the steel industry and Andrew Mellon was a successful banker.</p>
</blockquote>
<h2 id="installing-sbcl"><a class="header" href="#installing-sbcl">installing sbcl</a></h2>
<p>On a Mac with macos:</p>
<pre><code>&gt; brew install sbcl
</code></pre>
<p>On a linux machine with ubuntu:</p>
<pre><code>&gt; sudo apt install sbcl
</code></pre>
<p>To check your installation:</p>
<pre><code>&gt; sbcl --version
SBCL 2.3.4
</code></pre>
<h2 id="wrapping-interactive-sessions-with-rlwrap"><a class="header" href="#wrapping-interactive-sessions-with-rlwrap">wrapping interactive sessions with <code>rlwrap</code></a></h2>
<p>As <code>sbcl</code> doesn't allow command editing and navigation in command history, we will wrap our sbcl sessions with the command: <code>rlwrap sbcl</code>.</p>
<p>On a Mac with macos:</p>
<pre><code>&gt; brew install rlwrap
</code></pre>
<p>On a linux machine with ubuntu:</p>
<pre><code>&gt; sudo apt install rlwrap
</code></pre>
<h2 id="the-read-eval-print-loop"><a class="header" href="#the-read-eval-print-loop">the Read-Eval-Print Loop</a></h2>
<p>Let's play a bit with <em>sbcl</em>.</p>
<pre><code>&gt; rlwrap sbcl
This is SBCL 2.3.4, an implementation of ANSI Common Lisp.
More information about SBCL is available at &lt;http://www.sbcl.org/&gt;.

SBCL is free software, provided as is, with absolutely no warranty.
It is mostly in the public domain; some portions are provided under
BSD-style licenses.  See the CREDITS and COPYING files in the
*
</code></pre>
<p>Sbcl is waiting for an input from the user. To leave the REPL, enter <code>(exit)</code> or type <code>&lt;CTL-D&gt;</code></p>
<pre><code>* 42
42
* 17
17
* (exit)
&gt;
</code></pre>
<h2 id="functions"><a class="header" href="#functions">Functions</a></h2>
<p>In lisp, calling a function is done by typing a list in which the first element is the function name and all the following elements if any are arguments. Here's an example (yes, <code>+</code> is a function):</p>
<pre><code>* (+ 42 17)
59
</code></pre>
<p>A function can be called inside a function call (as long as we don't forget any parenthesis!)</p>
<pre><code>* (- (* (+ 42 17) 82) (- (* 4 8) 1))
4807
</code></pre>
<p>Here are some interesting functions:</p>
<pre><code>* (list 1 2 3 4 5)
(1 2 3 4 5)
* (defvar numbers (list 42 17 23 4807))
NUMBERS
* (car numbers)
42
* (cdr numbers)
(17 23 4807)
* (car (cdr numbers))
17
* (cadr numbers)
17
* (caddr numbers)
23
* (length numbers)
4
* (null numbers)
NIL
* (not (null numbers))
T
</code></pre>
<h2 id="quote"><a class="header" href="#quote">Quote</a></h2>
<p>Not every value in lisp is a number. To represent symbolic values, we can use the <code>quote</code> function, or  <code>'</code>:</p>
<pre><code>* (quote foo)
FOO
* 'bar
BAR
</code></pre>
<p>We can quote symbols but also lists (of symbols or whatever). <code>quote</code> means: <em>don't evaluate this</em>.</p>
<pre><code>* (quote (foo bar qux))
(FOO BAR QUX)
* '(+ 17 23)
(+ 17 23)
</code></pre>
<h2 id="conditions"><a class="header" href="#conditions">Conditions</a></h2>
<p><code>T</code> and <code>NIL</code> are the boolean values for respectively <em>true</em> and <em>false</em>. <code>NIL</code> is also the value for empty lists. To evaluate expressions according to a condition, we can use the <code>if</code> form:</p>
<pre><code>* (if (= 42 (* 6 7)) 'correct 'wrong)
CORRECT
</code></pre>
<p>or we can use the <code>cond</code> form:</p>
<pre><code>* (cond ((= 41 (* 6 7)) 'correct)
        ((= 23 (* 6 4)) 'wrong)
        (t '(everything above was false)))
(EVERYTHING ABOVE WAS FALSE)
</code></pre>
<h2 id="functions-1"><a class="header" href="#functions-1">Functions</a></h2>
<p>Functions can be defined with <code>defun</code>, followed by the name of the function, and the parameters (if any) between parentheses, then the body of the function.</p>
<pre><code>* (defun times-two (x) 
    (* x 2))
TIMES-TWO
* (times-two 42)
84
</code></pre>
<h2 id="variable-bindings"><a class="header" href="#variable-bindings">Variable bindings</a></h2>
<p>It is possible, using <code>let</code> to define <em>variables</em> and bind them to some values that are used in the last expression of the <code>let</code> form.</p>
<pre><code>* (let ((x 17)
        (y 23))
     (+ x y))
40
</code></pre>
<p>The <code>let*</code> form allows for defining bindings with variables previously bound in the same list. (<code>let</code> won't let you do that).</p>
<pre><code>* (let ((x 17)
        (y (+ 23 x))
    (+ x y))
; in: LET ((X 17) (Y (+ 23 X)))
;     (+ 23 X)
;
; caught WARNING:
;   undefined variable: COMMON-LISP-USER::X
;
; compilation unit finished
;   Undefined variable:
;     X
;   caught 1 WARNING condition

debugger invoked on a UNBOUND-VARIABLE @535733C0 in thread
#&lt;THREAD &quot;main thread&quot; RUNNING {10044A0113}&gt;:
  The variable X is unbound.
…
(let* ((x 17)
       (y (+ x 23)))
   (+ x y))
57
</code></pre>
<h2 id="lists-and-recursion"><a class="header" href="#lists-and-recursion">Lists and recursion</a></h2>
<p>Recursive functions — functions that call themselves — work very well with lists. Here's an example:</p>
<pre><code class="language-(">* (defun size (l)
    (if (null l)
        0 
        (1+ (size (cdr l)))
    )
  )
SIZE
* (size '(A B C D E))
5
</code></pre>
<h2 id="creating-lists"><a class="header" href="#creating-lists">Creating Lists</a></h2>
<p>How do we construct a list element by element? We use <code>cons</code>:</p>
<pre><code>* (cons 'A nil)
(A)
* (cons 'A (cons 'B (cons 'C nil)))
(A B C)
</code></pre>
<p>Here's a function that creates the list of all numbers between <em>n</em> and <em>m</em>:</p>
<pre><code>* (defun seq (n m)
    (if (&gt; n m)
        nil
        (cons n (seq (1+ n) m))
    )
  )
SEQ
* (seq 17 23)
(17 18 19 20 21 22 23)
</code></pre>
<h2 id="executing-lisp-scripts"><a class="header" href="#executing-lisp-scripts">Executing lisp scripts</a></h2>
<p>To execute a script written in lisp with sbcl, launch sbcl with the <code>--script</code> option. Suppose we have a script file name <code>my-script.lisp</code> that prints the result of an addition,</p>
<pre><code>; my-script.lisp  prints the result of an addition
(print (+ 23 17 2))
</code></pre>
<p>then this script can be executed as a stand-alone program:</p>
<pre><code>&gt; sbcl --script my-script.lisp
42
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="writing-tests"><a class="header" href="#writing-tests">Writing Tests</a></h1>
<h2 id="unit-tests"><a class="header" href="#unit-tests">Unit Tests</a></h2>
<p>To create unit tests in lisp, we will use the <a href="https://github.com/OdonataResearchLLC/lisp-unit">lisp-unit</a> library.</p>
<p>A simple way to make it available for our tests scripts is to copy <code>lips-unit.lisp</code> in the standard location for lisp libraries:</p>
<pre><code>cp lisp-unit.lisp ~/.local/share/common-lisp/source/.
</code></pre>
<p>(Or any better location).</p>
<p>Here's a test script with a dummmy test in it.</p>
<pre><code>; tests.lisp
(require &quot;lisp-unit&quot; &quot;~/.local/share/common-lisp/source/lisp-unit.lisp&quot;)
; set up testing option
(in-package :lisp-unit)
(setq *print-failures* t)

(define-test dummy-test
    (assert-equal 5 (+ 2 2)))

(run-tests :all)
</code></pre>
<p>When we run this script, we get a test report:</p>
<pre><code> | Failed Form: (+ 2 2)
 | Expected 5 but saw 4
 |
DUMMY-TEST: 0 assertions passed, 1 failed.

Unit Test Summary
 | 1 assertions total
 | 0 passed
 | 1 failed
 | 0 execution errors
 | 0 missing tests
</code></pre>
<h2 id="acceptance-tests"><a class="header" href="#acceptance-tests">Acceptance Tests</a></h2>
<p>The way we are going to create acceptance tests is very straightforward:</p>
<ul>
<li>we'll create a <code>test-cases.txt</code> file and fill it with a series of test cases</li>
<li>we'll create a reference file <code>expected.txt</code> which will contain the expected results for the test cases</li>
<li>to test the program, we will run it, feeding it with the acceptance test cases file, and capturing the output in a <code>results.txt</code> file</li>
<li>then we will compare <code>expected.txt</code> and <code>results.txt</code> for an exact match.</li>
</ul>
<p>This is our test cases file: <code>test-cases.txt</code></p>
<pre><code>5
4
3 5 2 7
6
10 5 4 10 5 2
12
10 10 10 10 10 10 10 10 10 10 10 10
20
3 5 3 5 3 5 3 5 3 5 3 5 3 5 3 5 3 5 3 5
3
10 10 10
</code></pre>
<p>And this is the expected result file: <code>expected.txt</code></p>
<pre><code>17
52
300
80
30
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="automating-tasks"><a class="header" href="#automating-tasks">Automating tasks</a></h1>
<p>To automate our different tasks we can use <code>make</code>. With this <code>Makefile</code>:</p>
<pre><code class="language-Makefile">unit: tests.lisp bowling.lisp
	sbcl --script tests.lisp

accept: bowling.lisp test-cases.txt expected.txt score.lisp
	sbcl --script score.lisp &lt;test-cases.txt &gt;results.txt
	diff expected.txt results.txt
</code></pre>
<p>These tasks cannot be executed as long as the files they depend on are not present. So let's fix that:</p>
<pre><code>&gt; touch bowling.lisp
&gt; echo &quot;(print 42) (terpri)&quot; &gt;score.lisp
</code></pre>
<p>Now we can launch our testing tasks:</p>
<pre><code>&gt; make unit
sbcl --script tests.lisp
 | Failed Form: (+ 2 2)
 | Expected 5 but saw 4
 |
DUMMY-TEST: 0 assertions passed, 1 failed.

Unit Test Summary
 | 1 assertions total
 | 0 passed
 | 1 failed
 | 0 execution errors
 | 0 missing tests

&gt; make accept
sbcl --script score.lisp &lt;test-cases.txt &gt;results.txt
diff expected.txt results.txt
1,5c1,2
&lt; 17
&lt; 52
&lt; 300
&lt; 80
&lt; 60
---
&gt; 
&gt; 42 
make: *** [Makefile:6 : accept] Error 1
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="the-bowling-score-kata"><a class="header" href="#the-bowling-score-kata">The Bowling Score Kata</a></h1>
<p>The TDD method consists in creating capacities for the program one step at a time, following a cycle of </p>
<ul>
<li>writing a failing test</li>
<li>make the pass</li>
<li>refactor</li>
</ul>
<p>Our todo list for the Bowling Score Kata starts with simple cases and progressively adds features :</p>
<ul>
<li>averages games (no bonus points)</li>
<li>strike roll on the first frame</li>
<li>strike rolls on any frame</li>
<li>spare on the first frame</li>
<li>spares on any frames</li>
<li>tenth frame rule (only bonus rolls are counted)</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="simple-games"><a class="header" href="#simple-games">Simple Games</a></h1>
<p>Starting with the simplest case allows us to take care of the inevitable mistakes in writing code in a language that we don't master.
Here's a simple case: when no roll has been thrown yet, the score is zero.</p>
<pre><code>; tests.lisp
(require &quot;lisp-unit&quot; &quot;~/.local/share/common-lisp/source/lisp-unit.lisp&quot;)
; set up testing options
(in-package :lisp-unit)
(setq *print-failures* t)
(load &quot;bowling&quot;)

(define-test when-no-rolls-yet-score-is-zero
    (assert-equal 0 (score ())))

(run-tests :all)
</code></pre>
<p>We make the test pass with the simplest code that can possibly work:</p>
<pre><code>; bowling.lisp
(defpackage :bowling
(:export :score))

(defun score (rolls)
    0)
</code></pre>
<p>Easy. Here's another case, one roll.</p>
<pre><code>(define-test when-only-one-rolls-score-is-this-roll
    (assert-equal 7 (score (list 7))))
</code></pre>
<p>To make it pass, we add a <code>cond</code> on the rolls list:</p>
<pre><code>(defun score (rolls)
  (cond ((null rolls) 0)
        (t (car rolls))))
</code></pre>
<p>From here we can make fast progress. Let's add a test for several rolls, no bonus throw.</p>
<pre><code>(define-test when-given-average-rolls-score-is-the-sum-of-the-rolls
    (assert-equal 27 (score (list 4 5 3 6 2 7))))
</code></pre>
<p>We make it pass by installing recursion in the <code>score</code> function:</p>
<pre><code>(defun score (rolls)
  (cond ((null rolls) 0)
        (t (+ (car rolls) (score (cdr rolls))))))
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="strikes--spares"><a class="header" href="#strikes--spares">Strikes &amp; Spares</a></h1>
<h2 id="strikes"><a class="header" href="#strikes">Strikes</a></h2>
<p>If the first roll knocked all the pins, it's a strike: the two following rolls will be added to the score as supplementary points.</p>
<pre><code>(define-test after-a-strike-on-first-frame-next-two-rolls-add-bonus-points
    (assert-equal 28 (score (list 10 5 4))))
</code></pre>
<p>We are adding a clause for strikes the <code>cond</code>: if the roll is a strike, then add the roll to the result, plus the next one, plus the following one, and proceed with the rest of the rolls.</p>
<pre><code>(defun score (rolls)
  (cond ((null rolls) 0)
        ((= 10 (car rolls)) (+ (car rolls)
                               (cadr rolls)
                               (caddr rolls)
                               (score (cdr rolls))))
        (t (+ (car rolls) (score (cdr rolls))))))
</code></pre>
<p>A problem with this code is that it might break in case the list does not include <em>all</em> the following rolls yet. 
Let's update this test with new assertions to take that possibility into account</p>
<pre><code>(define-test after-a-strike-on-first-frame-next-two-rolls-if-any-add-bonus-points
    (assert-equal 28 (score (list 10 5 4)))
    (assert-equal 20 (score (list 10 5)))
    (assert-equal 10 (score (list 10))))
</code></pre>
<p>Now we have an execution error, because acessing <code>(cadr rolls)</code> when <code>rolls</code> has only one element yields <code>nil</code> and <code>nil</code> cannot be added to a number. We have to make sure we that the rolls we are adding to the score are values.</p>
<pre><code>(defun score (rolls)
  (cond ((null rolls) 0)
        ((= 10 (car rolls)) (+ (car rolls)
                               (if (not (null (cadr rolls))) (cadr rolls) 0)
                               (if (not (null (caddr rolls))) (caddr rolls) 0)
                               (score (cdr rolls))))
        (t (+ (car rolls) (score (cdr rolls))))))
</code></pre>
<p>The test pass. Now we can refactor the messy code a bit.</p>
<pre><code>(defun any (x)
     (if (not (null x)) x 0))

(defun score (rolls)
  (cond ((null rolls) 0)
        ((= 10 (car rolls)) (+ (car rolls)
                               (any (cadr rolls))
                               (any (caddr rolls))
                               (score (cdr rolls))))
        (t (+ (car rolls) (score (cdr rolls))))))
</code></pre>
<h2 id="spares"><a class="header" href="#spares">Spares</a></h2>
<p>Let's add the case for a spare in the first frame.</p>
<pre><code>(define-test after-a-spare-on-first-frame-next-roll-if-any-add-bonus-points
    (assert-equal 20 (score (list 2 8 5))))
</code></pre>
<p>To make this test pass, we add a clause to the <code>cond</code>:</p>
<pre><code>(defun score (rolls)
  (cond ((null rolls) 0)
        ((= 10 (car rolls)) (+ (car rolls)
                               (any (cadr rolls))
                               (any (caddr rolls))
                               (score (cdr rolls))))
        ((= 10 (+ (car rolls) (any (cadr rolls)))) (+ (car rolls)
                                                      (any (cadr rolls))
                                                      (any (caddr rolls))
                                                      (score (cddr rolls))))
        (t (+ (car rolls) (score (cdr rolls))))))
</code></pre>
<p>Here again, we can refactor: let's make the code clearer by creating helper functions.</p>
<pre><code>(defun any (x)
     (if (not (null x)) x 0))

(defun frame-plus-bonus (rolls)
  (+ (car rolls) (any (cadr rolls)) (any (caddr rolls))))

(defun strike (rolls)
  (= 10 (car rolls)))

(defun spare (rolls)
  (= 10 (+ (car rolls) (any (cadr rolls)))))

(defun score (rolls)
  (cond ((null rolls) 0)
        ((strike rolls) (+ (frame-plus-bonus rolls) (score (cdr rolls))))
        ((spare rolls) (+ (frame-plus-bonus rolls) (score (cddr rolls))))
        (t (+ (car rolls) (score (cdr rolls))))))
</code></pre>
<p>Let's add a general test of this function for good measure.</p>
<pre><code>(define-test after-some-strikes-and-spares-bonus-rolls-are-added
    (assert-equal 73 (score (list 5 5  4 5  8 2  10  0 10 0 0)))
    (assert-equal 37 (score (list 5 5  4 0  8 1  10  0 0)))
    (assert-equal 151 (score (list 5 5  4 0  8 1  10  0 10  10  10  10  4 6  0 0))))
</code></pre>
<p>They pass: provided that no illegal game — like <code>(list 5 10 2)</code> for instance — is given, our score function works… until the 10th frame at least.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="the-tenth-frame"><a class="header" href="#the-tenth-frame">The Tenth Frame</a></h1>
<p>Once the tenth frame has been played, the only rolls that can be counted are the extra ones generated by a strike or a spare in the tenth frame. Thus, the score for throwing 12 strikes is exactly 300. </p>
<pre><code>(define-test after-tenth-frame-extra-rolls-count-only-as-bonus
    (assert-equal 300 (score (list 10 10 10 10 10 10 10 10 10 10 10 10))))
</code></pre>
<p>The test fails:</p>
<pre><code> | Failed Form: (SCORE (LIST 10 10 10 10 10 10 10 10 10 10 10 10))
 | Expected 300 but saw 330
 |
AFTER-TENTH-FRAME-EXTRA-ROLLS-COUNT-ONLY-AS-BONUS: 0 assertions passed, 1 failed.
</code></pre>
<p>Let's respond with a hard coded comparison for now.</p>
<pre><code>(defun score (rolls)
  (cond ((null rolls) 0)
        ((equal (list 10 10 10 10 10 10 10 10 10 10 10 10) rolls) 300) 
        ((strike rolls) (+ (frame-plus-bonus rolls)
                           (score (cdr rolls))))
        ((spare rolls) (+ (frame-plus-bonus rolls)
                          (score (cddr rolls))))
        (t (+ (car rolls)
              (score (cdr rolls))))))
</code></pre>
<p>The tenth frame limit requires that we count frame while we are examining them for points, and that when the frame count is greater or equal to 10, the counting stops.
Let's start by adding a <code>frame</code> parameter to our function.</p>
<pre><code>(defun score-at-frame (frame rolls)
  (cond ((null rolls) 0)
        ((equal (list 10 10 10 10 10 10 10 10 10 10 10 10) rolls) 300) 
        ((strike rolls) (+ (frame-plus-bonus rolls)
                           (score-at-frame frame (cdr rolls))))
        ((spare rolls) (+ (frame-plus-bonus rolls)
                          (score-at-frame frame (cddr rolls))))
        (t (+ (car rolls)
              (score-at-frame frame (cdr rolls))))))

(defun score (rolls)
  (score-at-frame 0 rolls))
</code></pre>
<p>Now we can add a clause to the <code>cond</code> and increase the <code>frame</code> argument at each recursive call.</p>
<pre><code>(defun score-at-frame (frame rolls)
  (cond ((null rolls) 0)
        ((&gt;= frame 10) 0)
        ((strike rolls) (+ (frame-plus-bonus rolls)
                           (score-at-frame (1+ frame) (cdr rolls))))
        ((spare rolls) (+ (frame-plus-bonus rolls)
                          (score-at-frame (1+ frame) (cddr rolls))))
        (t (+ (car rolls)
              (score-at-frame (1+ frame) (cdr rolls))))))
</code></pre>
<p>The last clause is wrong of coure, since we increase the frame number while advancing only for one roll in the list.
And one of the tests is telling us that:</p>
<pre><code> | Failed Form: (SCORE (LIST 5 5 4 0 8 1 10 0 10 10 10 10 4 6 0 0))
 | Expected 151 but saw 141
 |
AFTER-SOME-STRIKES-AND-SPARES-BONUS-ROLLS-ARE-ADDED: 2 assertions passed, 1 failed.
</code></pre>
<p>The frame counting is incorrect here:</p>
<pre><code>frame:  0 1 2 3 4 5 6  7 8  9  10 
rolls: |5 5|4 0|8 1|10|0 10|10|10|10|4 6|0 0|
</code></pre>
<p>Let's fix this. The last clause of the function will add the current roll plus the next one (if any), then it will recusively call <code>score-at-frame</code> with an increased frame number.</p>
<pre><code>(defun score-at-frame (frame rolls)
  (cond ((null rolls) 0)
        ((&gt;= frame 10) 0)
        ((strike rolls) (+ (frame-plus-bonus rolls)
                           (score-at-frame (1+ frame) (cdr rolls))))
        ((spare rolls) (+ (frame-plus-bonus rolls)
                          (score-at-frame (1+ frame) (cddr rolls))))
        (t (+ (car rolls) (any (cadr rolls))
                          (score-at-frame (1+ frame) (cddr rolls))))))
</code></pre>
<p>There are 3 possibilities for matching this last clause:</p>
<ul>
<li><code>rolls</code> contains only 1 roll (and it's not a 10) : then <code>(any (cadr rolls))</code> is 0 and <code>nil</code> is passed to the next recursive call</li>
<li><code>rolls</code> contains 2 rolls (ant it's not a spare) : then the 2 rolls are added and <code>rolls</code> and <code>nil</code> is passed to the next recursive call</li>
<li><code>rolls</code> contains more than 2 rolls (and we don't have a spare): then we add these rolls and continue with the correct frame number</li>
</ul>
<p>Let's add some assertions to increase our confidence in that reasoning:</p>
<pre><code>(define-test after-tenth-frame-extra-rolls-count-only-as-bonus
    (assert-equal 300 (score (list 10 10 10 10 10 10 10 10 10 10 10 10)))
    (assert-equal 266 (score (list 10 10 10 10 10 10 10 10 10 4 6 2)))
    (assert-equal 262 (score (list 10 10 10 10 10 10 10 10 10 4 5)))
    (assert-equal 264 (score (list 10 10 10 10 10 10 10 10 10 4 6 0))))
</code></pre>
<p>They all pass.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="the-score-program"><a class="header" href="#the-score-program">The Score Program</a></h1>
<p>Now that we have a working score calculator, we can use it in the main program so that this program can effectively read its input, calculate, and then print the scores corresponding to the games given in the input.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="input--output"><a class="header" href="#input--output">Input &amp; Output</a></h1>
<h2 id="reading-from-standard-input-stream"><a class="header" href="#reading-from-standard-input-stream">Reading from standard input stream</a></h2>
<p>The <code>read</code> function can read any value from the standard input. Here's an example: the following expression waits for a number on the standard input and then calculate its square.</p>
<pre><code>* (let ((x (read))) (* x x))
42 ↵
1764
</code></pre>
<h2 id="reading-from-a-file"><a class="header" href="#reading-from-a-file">Reading From a File</a></h2>
<p>If we can read values from the standard input as a source, it must be possible to read from another source ?</p>
<p>Of course! Let's try it:</p>
<pre><code>&gt; echo &quot;4807&quot; &gt;value.txt
&gt; rlwrap sbcl
* (defvar *my-stream* (open &quot;./value.txt&quot;))
MY-STREAM
* (read *my-stream*)
4807
</code></pre>
<p>Can we read <em>several</em> values, and put them in a list ? Again, let's try.</p>
<pre><code>&gt; echo &quot;42&quot; &gt;values.txt
&gt; echo &quot;17&quot; &gt;&gt;values.txt
&gt; echo &quot;23&quot; &gt;&gt;values.txt
&gt; cat values.txt
42
17
23
&gt; rlwrap sbcl
* (defvar *s* (open &quot;./values.txt&quot;))
*S*
* (let ((v1 (read *s*)) (v2 (read *s*)) (v3 (read *s*)))
    (cons v1 (cons v2 (cons v3 nil))))
(42 17 23)
</code></pre>
<h2 id="reading-from-a-string"><a class="header" href="#reading-from-a-string">Reading from a string</a></h2>
<p>The <code>read</code> function is truly powerful. It can actually read from any <em>stream</em>, be it the standard input stream, an opened file, or a stream formed with a given string.</p>
<p>The function <code>with-input-from-string</code> allow us to </p>
<ul>
<li>define a named stream</li>
<li>use it in a form as a source stream for <code>read</code></li>
</ul>
<p>Here are examples:</p>
<pre><code>* (with-input-from-string (s &quot;42&quot;) (read s))
42
* (with-input-from-string (s  &quot;42 17&quot;) (cons (read s) (cons (read s) NIL)))
(42 17)
</code></pre>
<h2 id="reading-numbers-from-a-file-source"><a class="header" href="#reading-numbers-from-a-file-source">Reading numbers from a file source</a></h2>
<p>Let's build the function we need, one step at a time.</p>
<h3 id="reading-an-empty-source"><a class="header" href="#reading-an-empty-source">Reading an empty source</a></h3>
<p>Starting with trivial cases, when given a empty source, the function should return <code>NIL</code>.</p>
<pre><code>(define-test given-no-numbers-read-numbers-give-nil
    (let ((result (with-input-from-string (s &quot;&quot;) (read-numbers s))))
      (assert-equal nil result)))
</code></pre>
<p>Making this test pass with a <em>fake</em>:</p>
<pre><code>; bowling.lisp
(defpackage :bowling
(:export :score :read-numbers))

(defun read-numbers (source)
  nil)
</code></pre>
<p>Next, we add a test for reading a single value.</p>
<pre><code>(define-test given-one-number-read-numbers-give-a-list-with-this-number
    (let ((result (with-input-from-string (s &quot;42&quot;) (read-numbers s))))
      (assert-equal (list 42) result)))
</code></pre>
<p>To make our second test pass, reading one number, we have to detect that a numbers has been read from the source, or not. If there was a number, return a list with that number inside, if not, return <code>nil</code>.</p>
<pre><code>(defun read-numbers (source)
  (let ((n (read source)))
    (if (null n) nil
      (cons n nil))))
</code></pre>
<p>but now the result is unexpected: our test for empty source has an execution error:</p>
<pre><code>GIVEN-NO-NUMBERS-READ-NUMBERS-GIVE-NIL: 0 assertions passed, 0 failed, and an execution error.

GIVEN-ONE-NUMBER-READ-NUMBERS-GIVE-A-LIST-WITH-THIS-NUMBER: 1 assertions passed, 0 failed.
</code></pre>
<p>We have to try the function interactively to understand what is happening:</p>
<pre><code>sbcl --load bowling.lisp
* (with-input-from-string (s &quot;42&quot;) (read-numbers s))
(42)
* (with-input-from-string (s &quot;&quot;) (read-numbers s))

debugger invoked on a END-OF-FILE in thread
#&lt;THREAD &quot;main thread&quot; RUNNING {10044A0113}&gt;:
  end of file on #&lt;dynamic-extent STRING-INPUT-STREAM (unavailable) from &quot;&quot;&gt;
</code></pre>
<h2 id="dealing-with-eof"><a class="header" href="#dealing-with-eof">Dealing with EOF</a></h2>
<p>The &quot;end of file&quot; situation on our stream is an error condition that interrupts our program. 
This can be fixed with one of the (optional) parameters of <code>read</code>.</p>
<blockquote>
<p>Function <strong>READ</strong></p>
<ul>
<li>Syntax:
<ul>
<li><strong>read</strong> <em>&amp;optional input-stream eof-error-p eof-value recursive-p</em> =&gt; <em>object</em></li>
</ul>
</li>
<li>Arguments and Values:
<ul>
<li><em>input-stream</em> — an input stream designator.</li>
<li><em>eof-error-p</em> — a generalized boolean. The default is true.</li>
<li><em>eof-value</em> — an object. The default is nil.</li>
<li><em>recursive-p</em> — a generalized boolean. The default is false.</li>
<li><em>object</em> — an object (parsed by the Lisp reader) or the eof-value.<br />
…</li>
</ul>
</li>
</ul>
<p>If a file ends in a symbol or a number immediately followed by an end of file, <strong>read</strong> reads the symbol or number successfully; when called again, it sees the end of file and only then acts according to <em>eof-error-p</em>.</p>
</blockquote>
<p>We have to indicate that the end of file shouldn't be an error. Let's use a constant to document this.</p>
<pre><code>(defconstant NO-EOF-ERROR nil)

(defun read-numbers (source)
  (let ((n (read source NO-EOF-ERROR)))
    (if (null n) nil
      (cons n nil))))
</code></pre>
<p>Now all the tests pass.</p>
<h1 id="reading-a-list-of-numbers"><a class="header" href="#reading-a-list-of-numbers">Reading a List of Numbers</a></h1>
<p>Reading several numbers from the input source should be straightforward using recursion. Let's write a new test:</p>
<pre><code>; tests.lisp
; …
(define-test given-several-number-read-numbers-give-a-list-with-these-numbers
    (let ((result (with-input-from-string (s &quot;42 17 23&quot;) (read-numbers s))))
      (assert-equal (list 42 17 23) result)))
</code></pre>
<p>To make the test pass, we replace the last <code>nil</code> in the function, by a recursive call:</p>
<pre><code>(defun read-numbers (source)
  (let ((n (read source NO-EOF-ERROR)))
    (if (null n) nil
      (cons n (read-numbers source)))))
</code></pre>
<p>Can we try our function of some more numbers, for instance, the numbers that are in the <code>test-cases.txt</code> file ? </p>
<pre><code>5
4
3 5 2 7
6
10 5 4 10 5 2
12
10 10 10 10 10 10 10 10 10 10 10 10
20
3 5 3 5 3 5 3 5 3 5 3 5 3 5 3 5 3 5 3 5
3
10 10 10
</code></pre>
<p>Let's try!</p>
<pre><code>&gt; rlwrap sbcl --load &quot;bowling&quot;
* (read-numbers (open &quot;lisp/test-cases.txt&quot;))
(5 4 3 5 2 7 6 10 5 4 10 5 2 12 10 10 10 10 10 10 10 10 10 10 10 10 20 3 5 3 5
 3 5 3 5 3 5 3 5 3 5 3 5 3 5 3 5 3 10 10 10)
</code></pre>
<p>It works!</p>
<h2 id="printing-numbers-on-the-standard-output-stream"><a class="header" href="#printing-numbers-on-the-standard-output-stream">Printing numbers on the standard output stream</a></h2>
<p>Printing numbers can be done via the powerful function <code>format</code>. This function, given a destination of <code>T</code> will format and print any value on the standard output. If the destination is <code>NIL</code> the result is returned as a string instead of printed.</p>
<pre><code>* (format T &quot;~a~%&quot; 4807)
4807
0 (format NIL &quot;~a~%&quot; 42)
&quot;42
&quot;
</code></pre>
<p>Writing a function <code>format-numbers</code> is straighforward, and easier to write than to test, actually.</p>
<pre><code>(define-test given-a-list-of-numbers-format-them
    (let ((result (format-numbers NIL (list 4 2))))
      (assert-equal (list (format NIL &quot;~a~%&quot; 4)
                          (format NIL &quot;~a~%&quot; 2)) result)))
</code></pre>
<p>We create a list of <code>format</code>:</p>
<pre><code>(defun format-numbers (dest numbers)
  (cond ((null numbers) nil)
        (t (cons
             (format dest &quot;~a~%&quot; (car numbers)) 
             (format-numbers dest (cdr numbers))))))
</code></pre>
<p>And the test passes.
In fact, we can even simplify this function by using <code>mapcar</code> and <code>lambda</code>. </p>
<p><code>mapcar</code> applies a function to each element of a list, and <code>lambda</code> creates an anonymous function. Here are examples:</p>
<pre><code>* (mapcar #'1+ (list 1 2 3))
(2 3 4)
* ((lambda (n) (* n n)) 42)
1764
* (mapcar (lambda (n) (* n n)) (list 42 17 23))
(1764 289 529)
</code></pre>
<p>Let's rewrite <code>format-numbers</code>:</p>
<pre><code>(defun format-numbers (dest numbers)
  (mapcar (lambda (n) (format dest &quot;~a~%&quot; n)) numbers))
</code></pre>
<p>The tests pass.  We can try our function interactively:</p>
<pre><code>&gt; slwrap sbcl --load &quot;bowling&quot;
* (format-numbers T (list 4 8 0 7))
4
8
0
7
(NIL NIL NIL NIL)
</code></pre>
<p>It works!</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="processing-the-games-in-input"><a class="header" href="#processing-the-games-in-input">Processing the Games in Input</a></h2>
<p>As explained initially our program's task is to:</p>
<ul>
<li>read the input stream, taking all the numbers from there</li>
<li>interpret this list of numbers as <em>information</em> about the test cases:
<ul>
<li>a number <em>T</em> of tests cases followed by <em>T</em> series of
<ul>
<li>a number <em>N</em> of rolls in this test case, followed by</li>
<li><em>R1</em> <em>R2</em> … <em>RN</em> numbers: the rolls themselves for this test case</li>
</ul>
</li>
</ul>
</li>
<li>produce the scores for these games,</li>
<li>print each of these scores, separated by a new line.</li>
</ul>
<p>In this chapter, we will interest ourselves in the main function of our program. It will consume a list, and return a list.</p>
<p>For instance, processing the list <code>(3 2 8 0 4 8 1 7 2 5 8 1 7 2 6)</code> should result the list <code>(8 18 24)</code>. Why?</p>
<ul>
<li>the first number indicates 3 games to process. The data for these 3 games is formed by the list <code>(2 8 0 4 8 1 7 2 5 8 1 7 2 6)</code>.</li>
<li>the first number the first game has 2 rolls: <code>(8 0)</code> for which computing the score will yield <code>8</code>. The rest to process is the list <code>(4 8 1 7 2 5 8 1 7 2 6)</code>.</li>
<li>the second game has 4 rolls: <code>(8 1 7 2)</code> for which computing the score will yield <code>18</code>. The rest to process it the list <code>(5 8 1 7 2 6)</code></li>
<li>the third game has 5 rolls: <code>(8 1 7 2 6)</code> for a score of <code>24</code> and the rest to process is the empty list, which will end the process.</li>
</ul>
<h3 id="extracting-the-first-game-from-the-game-data"><a class="header" href="#extracting-the-first-game-from-the-game-data">Extracting the first game from the game data</a></h3>
<p>In order to process each game in turn, we need to generate 2 lists:</p>
<ul>
<li>the rolls for the current game to be processed (the lenght of this list is given by the very firt element of the data)</li>
<li>the rest of game data </li>
</ul>
<p>Here's test:</p>
<pre><code>(define-test given-game-data-extract-game-return-first-game-and-remaining-data
    (let ((result (extract-game (list 3 4 9 0 2 5 8))))
        (assert-equal '((4 9 0) 2 5 8) result)))
</code></pre>
<p>We can write this function using <code>subseq</code>, which given a list, a start index and an (optional) end index, returns the corresponding subsequence of the list. Here are some examples:</p>
<pre><code>* (defvar l '(a b c d e))
L
* (subseq l 0 3)
(A B C)
* (subseq l 3)
(D E)
</code></pre>
<p>Hence the function:</p>
<pre><code>(defun extract-game (games)
  (let* ((n (car games))
         (data (cdr games))
         (rolls (subseq data 0 n))
         (remain (subseq data n)))
    (cons rolls remain)))
</code></pre>
<p>And the test passes.</p>
<h3 id="extracting-all-the-games"><a class="header" href="#extracting-all-the-games">Extracting all the games</a></h3>
<p>From here, extracting all the games is easy: recursively extract each first game. 
Here's a test:</p>
<pre><code>(define-test given-game-data-extract-games-return-all-the-games
    (let ((result (extract-games (list 3 4 9 0 2 5 8))))
        (assert-equal '((4 9 0) (5 8)) result)))
</code></pre>
<pre><code>(defun extract-games (games)
    (cond ((null games) nil)
          (t (let* ((extraction (extract-game games))
                    (game (car extraction))
                    (remaining (cdr extraction)))
               (cons game (extract-games remaining))))))
</code></pre>
<p>We can try the function on the test cases. We must not forget to remove the first number in this list, which represents the number of test cases. This number is not needed, as we rely on the end of the list to stop the process.</p>
<pre><code>&gt; sbcl --load bowling.lisp&quot;
* (defvar data (read-numbers (open &quot;./lisp/test-cases.txt&quot;)))
DATA
* data
(5 4 3 5 2 7 6 10 5 4 10 5 2 12 10 10 10 10 10 10 10 10 10 10 10 10 20 3 5 3 5
 3 5 3 5 3 5 3 5 3 5 3 5 3 5 3 5 3 10 10 10)
* (extract-games (cdr data))
((3 5 2 7) (10 5 4 10 5 2) (10 10 10 10 10 10 10 10 10 10 10 10)
 (3 5 3 5 3 5 3 5 3 5 3 5 3 5 3 5 3 5 3 5) (10 10 10))
</code></pre>
<p>It works!</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="final-assembly"><a class="header" href="#final-assembly">Final Assembly</a></h1>
<p>We are almost done: the last step consists in assembling our functions in the main program, <code>score.lisp</code> ;</p>
<pre><code>; score.lisp
(load &quot;bowling&quot;)

(format-numbers T 
  (mapcar #'score 
          (extract-games 
                (cdr (read-numbers *standard-input*)))))
</code></pre>
<p>Now we can run the acceptance test:</p>
<pre><code>&gt; make accept
sbcl --script score.lisp &lt;test-cases.txt &gt;results.txt
diff expected.txt results.txt
</code></pre>
<p>No diff: the test passes. </p>
<p>We can also use the program interactively:</p>
<pre><code>&gt;sbcl --script score.lisp
1 ↵
5 ↵
10 3 4 2 0 ↵ &lt;ctl-D&gt;
26
</code></pre>
<p>And we are done!</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="source-code"><a class="header" href="#source-code">Source Code</a></h1>
<h2 id="testslisp"><a class="header" href="#testslisp">tests.lisp</a></h2>
<pre><code>; tests.lisp
(require &quot;lisp-unit&quot; &quot;~/.local/share/common-lisp/source/lisp-unit.lisp&quot;)
; set up testing options
(in-package :lisp-unit)
(setq *print-failures* t)
(load &quot;bowling&quot;)

(define-test when-no-rolls-yet-score-is-zero
    (assert-equal 0 (score ())))

(define-test when-only-one-rolls-score-is-this-roll
    (assert-equal 7 (score (list 7))))

(define-test when-given-average-rolls-score-is-the-sum-of-the-rolls
    (assert-equal 27 (score (list 4 5 3 6 2 7))))

(define-test after-a-strike-on-first-frame-next-two-rolls-if-any-add-bonus-points
    (assert-equal 28 (score (list 10 5 4)))
    (assert-equal 20 (score (list 10 5)))
    (assert-equal 10 (score (list 10))))

(define-test after-a-spare-on-first-frame-next-roll-if-any-add-bonus-points
    (assert-equal 20 (score (list 2 8 5))))

(define-test after-some-strikes-and-spares-bonus-rolls-are-added
    (assert-equal 73 (score (list 5 5  4 5  8 2  10  0 10 0 0)))
    (assert-equal 37 (score (list 5 5  4 0  8 1  10  0 0)))
    (assert-equal 151 (score (list 5 5  4 0  8 1  10  0 10  10  10  10  4 6  0 0))))

(define-test after-tenth-frame-extra-rolls-count-only-as-bonus
    (assert-equal 300 (score (list 10 10 10 10 10 10 10 10 10 10 10 10)))
    (assert-equal 266 (score (list 10 10 10 10 10 10 10 10 10 4 6 2)))
    (assert-equal 262 (score (list 10 10 10 10 10 10 10 10 10 4 5)))
    (assert-equal 264 (score (list 10 10 10 10 10 10 10 10 10 4 6 0))))

(define-test given-no-numbers-read-numbers-give-nil
    (let ((result (with-input-from-string (s &quot;&quot;) (read-numbers s))))
      (assert-equal nil result)))

(define-test given-one-number-read-numbers-give-a-list-with-this-number
    (let ((result (with-input-from-string (s &quot;42&quot;) (read-numbers s))))
      (assert-equal (list 42) result)))

(define-test given-several-number-read-numbers-give-a-list-with-these-numbers
    (let ((result (with-input-from-string (s &quot;42 17 23&quot;) (read-numbers s))))
      (assert-equal (list 42 17 23) result)))

(define-test given-a-list-of-numbers-format-them
    (let ((result (format-numbers NIL (list 4 2))))
      (assert-equal (list (format NIL &quot;~a~%&quot; 4)
                          (format NIL &quot;~a~%&quot; 2)) result)))

(define-test given-game-data-extract-game-return-first-game-and-remaining-data
    (let ((result (extract-game (list 3 4 9 0 2 5 8))))
        (assert-equal '((4 9 0) 2 5 8) result)))

(define-test given-game-data-extract-games-return-all-the-games
    (let ((result (extract-games (list 3 4 9 0 2 5 8))))
        (assert-equal '((4 9 0) (5 8)) result)))
(run-tests :all)
</code></pre>
<h2 id="bowlinglisp"><a class="header" href="#bowlinglisp">bowling.lisp</a></h2>
<pre><code>; bowling.lisp
(defpackage :bowling
(:export :score :read-numbers))

(defconstant NO-EOF-ERROR nil)

(defun extract-game (games)
  (let* ((n (car games))
         (data (cdr games))
         (rolls (subseq data 0 n))
         (remain (subseq data n)))
    (cons rolls remain)))

(defun extract-games (games)
    (cond ((null games) nil)
          (t (let* ((extraction (extract-game games))
                    (game (car extraction))
                    (remaining (cdr extraction)))
               (cons game (extract-games remaining))))))

(defun read-numbers (source)
  (let ((n (read source NO-EOF-ERROR)))
    (if (null n) nil
      (cons n (read-numbers source)))))

(defun format-numbers (dest numbers)
  (mapcar (lambda (n) (format dest &quot;~a~%&quot; n)) numbers))

(defun any (x)
     (if (not (null x)) x 0))

(defun frame-plus-bonus (rolls)
  (+ (car rolls) (any (cadr rolls)) (any (caddr rolls))))

(defun strike (rolls)
  (= 10 (car rolls)))

(defun spare (rolls)
  (= 10 (+ (car rolls) (any (cadr rolls)))))

(defun score-at-frame (frame rolls)
  (cond ((null rolls) 0)
        ((&gt;= frame 10) 0)
        ((strike rolls) (+ (frame-plus-bonus rolls)
                           (score-at-frame (1+ frame) (cdr rolls))))
        ((spare rolls) (+ (frame-plus-bonus rolls)
                          (score-at-frame (1+ frame) (cddr rolls))))
        (t (+ (car rolls) (any (cadr rolls))
              (score-at-frame (1+ frame) (cddr rolls))))))

(defun score (rolls)
  (score-at-frame 0 rolls))
</code></pre>
<h3 id="scorelisp"><a class="header" href="#scorelisp">score.lisp</a></h3>
<pre><code>; score.lisp
(load &quot;bowling&quot;)

(format-numbers T 
  (mapcar #'score 
          (extract-games 
                (cdr (read-numbers *standard-input*)))))
</code></pre>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </div>
    </body>
</html>
